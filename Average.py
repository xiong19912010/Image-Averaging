#!/usr/bin/env python
# coding: utf-8

# ## Parse the star file

# In[1]:


import starfile
import pandas as pd
import os
import fire
from fire import core
import shutil
import imutils
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from scipy.optimize import curve_fit
from scipy.optimize import least_squares
import mrcfile
from scipy.ndimage import map_coordinates
from scipy.spatial.transform import Rotation as R
pd.options.mode.chained_assignment = None
path_current=os.getcwd()


# ## Calculate the Rotation Matrix between Two 3D points

# In[2]:

class Average:
    '''
    This command is used to averge the subtomograms along each TubeID and it considers the orientation of each subtomogram \n
    For more detailed information, please run the following command:
    python3 Average.py image_average -h
    '''
    def image_average(self,particle_star_file,image_folder):
        '''
        python3 Average.py particles.star Subtomograms
        :param particle_star_file: This is the [particles.star] generated by Relion
        :param image_folder: This is the [Subtomograms]
        '''
        ### calculate the rotation matrix between two 3D vectors. Pay attention here that we only care abou the angles so we should normalize the vectors first.
        def Rotation_matrix(p0,p1):
            from numpy import linalg as LA
            # two random 3D vectors
            p0 = np.array(p0)
            p1 = np.array(p1)
            # calculate cross and dot products
            C = np.cross(p0, p1) ;
            D = np.dot(p0, p1) ;
            NP0 = LA.norm(p0) ; # used for scaling
            j=0
            for i in range(0, len(C)):
                if C[i]==0:
                    j=j+1
            if j<len(C): # check for colinearity
                Z = np.array([[0, -C[2], C[1]], [C[2], 0, -C[0]], [-C[1], C[0], 0]]);
                R = (np.eye(3) + Z + np.dot(Z,Z)* (1-D)/(LA.norm(C)**2)) / NP0**2 ; # rotation matrix
            else:
                R = np.sign(D) * (LA.norm(p1) / NP0) ; # orientation and scaling
                R = np.eye(3)
            return R
            
        ### Rotate Image based on Rotation Matrix
        def Image_rotation_3D(array, orient):
            rot = orient[1]
            tilt = orient[2]
            phi = orient[0]

            # create meshgrid
            dim = array.shape
            ax = np.arange(dim[0])
            ay = np.arange(dim[1])
            az = np.arange(dim[2])
            coords = np.meshgrid(ax, ay, az)

            # stack the meshgrid to position vectors, center them around 0 by substracting dim/2
            xyz = np.vstack([coords[0].reshape(-1) - float(dim[0]) / 2,  # x coordinate, centered
                             coords[1].reshape(-1) - float(dim[1]) / 2,  # y coordinate, centered
                             coords[2].reshape(-1) - float(dim[2]) / 2])  # z coordinate, centered
            
            # create transformation matrix
            r = R.from_euler('xyz', [rot, tilt, phi], degrees=True)
            mat = r.as_matrix()
            
           
            # apply transformation
            transformed_xyz = np.dot(mat, xyz)
            
            # extract coordinates
            x = transformed_xyz[0, :] + float(dim[0]) / 2
            y = transformed_xyz[1, :] + float(dim[1]) / 2
            z = transformed_xyz[2, :] + float(dim[2]) / 2

            x = x.reshape((dim[1],dim[0],dim[2]))
            y = y.reshape((dim[1],dim[0],dim[2]))
            z = z.reshape((dim[1],dim[0],dim[2])) # I test the rotation in 2D and this strange thing can be explained
            new_xyz = [y,x,z]
            arrayR = map_coordinates(array, new_xyz, order=1)
            return arrayR
            
        ## create a folder to store the averaged mrcs
        print('Processing ................')
        folder_name='Subtomograms_Average'
        star_file_name='new_particles.star'
        output_average_mrc_folder=os.path.join(path_current,folder_name)
        if os.path.exists(output_average_mrc_folder):
            shutil.rmtree(output_average_mrc_folder)
        os.mkdir(output_average_mrc_folder)
        ## import particles_star_file
        particle_star=starfile.read(particle_star_file)
        particle_star=pd.DataFrame([particle_star]).iloc[0,1]
        subtomogram_names=particle_star['rlnTomoName'].unique()
        subtomogram_names=['SpermTS_002','SpermTS_003']
        
        ## create a new star file to store the information
        New_particle_star=pd.DataFrame()
        
        for subtomogram_name in subtomogram_names:
            split_star=pd.DataFrame()
            split_star=particle_star[particle_star['rlnTomoName']==subtomogram_name].reset_index(drop=True)
            ## sorted the coordinates and split out the image names
            Imagenames=split_star['rlnImageName']
            Imagenames_split=Imagenames.str.split('/',expand=True)
            Imagenames_only=Imagenames_split.iloc[:,Imagenames_split.shape[1]-1]
            split_star['Imagename']=Imagenames_only
            test=Imagenames_only.str.split('_',expand=True)
            test[0] = pd.to_numeric(test[0])
            split_star['Drop']=test[0]
            split_star=split_star.sort_values(by=['Drop']).reset_index(drop=True)
            split_star=split_star.drop(columns=['Drop'])
            
            ## deal with each subtomograms
            IDs=split_star['rlnHelicalTubeID'].unique()
            for ID in IDs:
                ## split the star file again based on TubeID
                
                xyz=pd.DataFrame()
                xyz=split_star[split_star['rlnHelicalTubeID']==ID].reset_index(drop=True)
                
                ## set the first 2 mrcs as the reference
                mrc_file_0=xyz['Imagename'][0]
                mrc_file_0_path=os.path.join(image_folder,subtomogram_name,mrc_file_0)
                total_mrc_0=np.array(mrcfile.open(mrc_file_0_path).data)
                mrc_file_1=xyz['Imagename'][1]
                mrc_file_1_path=os.path.join(image_folder,subtomogram_name,mrc_file_1)
                total_mrc_1=np.array(mrcfile.open(mrc_file_1_path).data)
                #total_mrc=total_mrc_0
                total_mrc=np.zeros([total_mrc_0.shape[0],total_mrc_0.shape[1],total_mrc_0.shape[2]],dtype=np.int16)
                for i in range(1,xyz.shape[0]):
                    mrc_file=xyz['Imagename'][i]
                    mrc_file_path=os.path.join(image_folder,subtomogram_name,mrc_file)
                    mrc_p1=np.array(mrcfile.open(mrc_file_path).data)

                    p_ref=xyz[['rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ']].iloc[1,:]-xyz[['rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ']].iloc[0,:]
                    #p_ref=np.array([0,1,0])
                    p_ref[2]=0
                    p_ref=p_ref / np.sqrt(np.sum(p_ref**2))
                    p1=xyz[['rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ']].iloc[i-1,:]
                    p2=xyz[['rlnCoordinateX','rlnCoordinateY','rlnCoordinateZ']].iloc[i,:]
                    p_21=p2-p1
                    p_21 = p_21 / np.sqrt(np.sum(p_21**2))
                    ## calculate rotation matrix and euler angle
                    m=Rotation_matrix(p_ref,p_21)
                    mat=R.from_matrix(m)
                    orient = mat.as_euler('xyz', degrees=True)
                    
                    # rotate image
                    mrc_p1_rotate=Image_rotation_3D(mrc_p1,orient)
                    ## averge image
                    total_mrc=mrc_p1_rotate+total_mrc
                    
#                plt.figure(figsize=(10, 10))
#                plt.subplot(133)
#                plt.title(subtomogram_name+'_'+str(ID)+'_Images_Total')
#                plt.imshow(total_mrc[31,:,:],cmap='gray')
                output_name=subtomogram_name+'_'+str(ID)+'_ID_average.mrc'
                output_path=os.path.join(output_average_mrc_folder,output_name)
                with mrcfile.new(output_path,overwrite=True) as mrc:
                        mrc.set_data(total_mrc/xyz.shape[0])
                intermid_star=pd.DataFrame(xyz.iloc[0,:]).T
                intermid_star=intermid_star.drop(columns=['Imagename'])
                intermid_star['rlnImageName']=output_path
                New_particle_star=New_particle_star.append(intermid_star,ignore_index=True)
        output_star_path=os.path.join(path_current,star_file_name)
        starfile.write(New_particle_star,output_star_path,overwrite=True)
        print('Averaging work is done!!!!!!!!!')
          
def Display(lines, out):
    text = "\n".join(lines) + "\n"
    out.write(text)


if __name__ == "__main__":
    core.Display = Display
    fire.Fire(Average)



